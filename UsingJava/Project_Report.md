# 자바 자료구조 구현 프로젝트 보고서 (Java Data Structure Implementation Report)

## 1. 프로젝트 개요

본 프로젝트(`UsingJava`)는 자바의 핵심 자료구조들을 직접 구현해보며 그 원리와 동작 방식을 깊이 있게 이해하는 것을 목표로 합니다.
`java.util` 패키지의 컬렉션 프레임워크를 단순히 사용하는 것을 넘어, 리스트, 스택, 큐, 맵, 셋, 힙, 그리고 레드-블랙 트리까지 직접 설계하고 구현하였습니다.

### 구현 목록 요약

| 자료구조 | 클래스명 | 내부 구현 | 특징 |
| :--- | :--- | :--- | :--- |
| **List** | `MyArrayList` | 동적 배열 (Dynamic Array) | `set()` 구현, 자동 크기 조절 |
| **Stack** | `MyStack` | `MyArrayList` | LIFO 구조, 동적 배열 기반 |
| **Queue** | `MyQueue` | 단순 연결 리스트 (Linked List) | FIFO 구조, O(1) 입출력 |
| **Heap** | `MyHeap` | `MyArrayList` | Min/Max Heap 지원 (Generic) |
| **Map** | `MyHashMap` | 해시 테이블 (Separate Chaining) | 충돌 처리, 빠른 검색 |
| **Map** | `MyLinkedHashMap` | 해시 테이블 + 이중 연결 리스트 | 입력 순서 보장, `keys()` 반환 |
| **Map** | `MyTreeMap` | **Red-Black Tree** | Key 기준 정렬, 자가 균형 유지 |
| **Set** | `MyHashSet` | `MyHashMap` | 중복 허용 안 함 |
| **Set** | `MyTreeSet` | `MyTreeMap` | 정렬된 집합, O(log n) |

---

## 2. 자료구조 상세 설명

### 2.1. List (리스트)

#### MyArrayList (동적 배열)
- **개념**: 배열의 크기가 부족하면 자동으로 늘려주는(Resizing) 리스트입니다.
- **특징**: 인덱스를 통한 조회(`get`, `set`)가 **O(1)**로 매우 빠릅니다.
- **단점**: 중간 삽입/삭제 시 데이터를 이동시켜야 하므로 **O(n)**의 시간이 소요됩니다.

#### MyLinkedList (단방향 연결 리스트) (참조용)
- **개념**: 노드들이 포인터로 연결된 구조입니다.
- **특징**: 중간 삽입/삭제가 포인터 변경만으로 가능하여 빠릅니다(위치를 아는 경우).
- **단점**: 인덱스 조회가 불가능하며, 처음부터 순회해야 하므로 조회가 느립니다(**O(n)**).

### 2.2. Stack & Queue (스택과 큐)

#### MyStack (스택)
- **구조**: `MyArrayList`를 내부적으로 사용하여 구현했습니다.
- **동작**: 후입선출(**LIFO**). 가장 나중에 들어온 데이터가 가장 먼저 나갑니다.
- **활용**: 함수 호출 스택, 실행 취소(Undo) 등.

#### MyQueue (큐)
- **구조**: 연결 리스트(Linked List)를 기반으로 구현하여, 큐의 크기에 제한이 없습니다.
- **동작**: 선입선출(**FIFO**). 가장 먼저 들어온 데이터가 가장 먼저 나갑니다.
- **성능**: `MyArrayList` 기반 큐와 달리, 앞쪽 데이터를 꺼낼 때 데이터를 당길 필요가 없어 입출력 모두 **O(1)**입니다.

### 2.3. Map (맵)

#### MyHashMap (해시 맵)
- **구조**: 해시 테이블(배열) + 연결 리스트(Separate Chaining).
- **원리**: Key의 해시 코드를 이용해 배열의 인덱스를 결정합니다.
- **성능**: 평균적으로 **O(1)**의 매우 빠른 속도로 데이터를 저장하고 조회합니다.

#### MyLinkedHashMap (연결 해시 맵)
- **구조**: `MyHashMap`의 구조에 **이중 연결 리스트**를 추가했습니다.
- **특징**: 데이터가 입력된 **순서(Insertion Order)**를 기억합니다.
- **활용**: 순서가 중요한 캐시(LRU Cache) 구현 등에 사용됩니다.

#### MyTreeMap (트리 맵)
- **구조**: **Red-Black Tree (자가 균형 이진 탐색 트리)**.
- **특징**: Key들이 정렬된 상태로 저장됩니다.
- **성능**: 데이터의 삽입, 삭제, 검색 모두 최악의 경우에도 **O(log n)**을 보장합니다.

### 2.4. Set (셋)

#### MyHashSet (해시 셋)
- **구조**: 내부적으로 `MyHashMap`을 사용합니다.
- **특징**: 데이터의 중복을 허용하지 않으며, 순서를 보장하지 않습니다.

#### MyTreeSet (트리 셋)
- **구조**: 내부적으로 `MyTreeMap`을 사용합니다.
- **특징**: 데이터가 중복되지 않으며, **정렬된 상태**를 유지합니다.

### 2.5. Heap (힙)

#### MyHeap (힙)
- **구조**: `MyArrayList`를 이용한 완전 이진 트리.
- **특징**: `Comparator`를 통해 **최소 힙(Min Heap)**과 **최대 힙(Max Heap)**을 모두 지원합니다.
- **활용**: 우선순위 큐(Priority Queue) 구현, 최댓값/최솟값 빠르게 찾기.

---

## 3. 핵심 알고리즘: Red-Black Tree (레드-블랙 트리)

이번 프로젝트의 핵심 도전 과제였던 **Red-Black Tree** 구현에 대한 상세 내용입니다.

### 개념 및 필요성
일반적인 이진 탐색 트리(BST)는 정렬된 데이터가 입력될 경우 트리가 한쪽으로 치우쳐(Skewed), 탐색 성능이 **O(n)**으로 저하되는 문제가 있습니다.
Red-Black Tree는 5가지 규칙을 통해 트리의 균형을 스스로 맞추어, 어떤 경우에도 트리의 높이를 **O(log n)**으로 유지합니다.

### 주요 구현 내용
1.  **Node 구조**: Key, Value 외에 `Color` (Red/Black) 속성을 추가.
2.  **회전 (Rotation)**: `rotateLeft`, `rotateRight`를 통해 트리의 구조를 재정비.
3.  **삽입 (Insertion)**:
    -   새 노드는 항상 **Red**로 삽입.
    -   **Double Red** 발생 시, 삼촌(Uncle) 노드의 색상에 따라 **Recoloring** 또는 **Rotation** 수행.
4.  **삭제 (Deletion)**: (기본 BST 삭제 로직 구현 / 재조정 로직은 복잡도를 고려하여 추후 과제로 남김)

---

## 4. 결론

본 프로젝트를 통해 자바의 다양한 자료구조를 밑바닥부터 구현해봄으로써 다음을 얻을 수 있었습니다.
- **메모리 구조 이해**: 배열과 리스트의 메모리 할당 및 관리 차이 이해.
- **알고리즘 적용**: 해시 충돌 해결, 트리 순회, 재귀 호출, 힙 정렬 등의 알고리즘 실습.
- **API 설계 능력**: 제네릭(Generic)을 활용한 범용 클래스 설계 및 인터페이스 정의.
- **최적화 경험**: `MyTreeMap`에 Red-Black Tree를 도입하여 성능 최적화.

이 보고서는 프로젝트의 산출물을 요약한 것이며, 상세 코드는 `src/main/java/datastructures` 패키지에서 확인할 수 있습니다.
