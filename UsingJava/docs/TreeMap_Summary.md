# Tree Map (트리 맵)

## 개념
**Tree Map**은 **Key-Value(키-값)** 쌍으로 데이터를 저장하며, **Key를 기준으로 정렬된 상태**를 유지하는 자료구조입니다.
`HashMap`과 달리 순서가 보장되므로 범위 검색이나 순차 처리가 필요한 경우에 유용합니다.

## 구조 (Red-Black Tree 방식)
이번 `MyTreeMap`은 **Red-Black Tree (자가 균형 이진 탐색 트리)** 구조를 기반으로 구현되었습니다.
기존의 BST는 데이터가 정렬된 순서로 들어올 경우 O(n)으로 성능이 저하되지만, Red-Black Tree는 항상 **O(log n)**의 성능을 보장합니다.

### Red-Black Tree란?
자가 균형 이진 탐색 트리의 일종으로, 다음 규칙을 만족하여 트리의 높이를 제한합니다.
1.  모든 노드는 **Red** 또는 **Black**입니다.
2.  루트는 항상 **Black**입니다.
3.  모든 리프(NIL)는 **Black**입니다.
4.  **Red** 노드의 자식은 항상 **Black**입니다. (Double Red 불가)
5.  어떤 노드에서 리프까지 가는 모든 경로에는 동일한 개수의 **Black** 노드가 있습니다.

```java
// 내부 Node 클래스
private static class Node<K, V> {
    K key;
    V value;
    Node<K, V> left;  // 작은 값
    Node<K, V> right; // 큰 값
}
```

## 주요 연산 및 시간 복잡도

| 연산 | 설명 | 시간 복잡도 (평균) | 시간 복잡도 (최악) |
| :--- | :--- | :--- | :--- |
| **Put (저장)** | 루트부터 비교하며 내려가 알맞은 위치에 추가하고 재조정(Rebalancing)합니다. | **O(log n)** | **O(log n)** |
| **Get (조회)** | 루트부터 비교하며 탐색합니다 (이진 탐색). | **O(log n)** | **O(log n)** |
| **Remove (삭제)** | 노드를 삭제하고, 트리의 구조를 재정비합니다. | **O(log n)** | **O(log n)** |

### 삭제 (Remove) 로직 상세
1.  **자식이 없는 경우 (Leaf Node)**: 그냥 삭제합니다.
2.  **자식이 하나인 경우**: 해당 자식을 현재 노드 자리로 올립니다.
3.  **자식이 둘인 경우**:
    -   오른쪽 서브 트리에서 **가장 작은 노드(Successor)**를 찾습니다.
    -   Successor의 값을 현재 노드로 복사하고, Successor 노드를 삭제합니다.

---
> [!NOTE]
> **자바의 실제 TreeMap**
> 자바의 `java.util.TreeMap`은 일반적인 BST 대신 **Red-Black Tree**를 사용합니다.
> 이는 데이터가 정렬된 순서로 들어오더라도 트리의 균형을 자동으로 맞춰, 최악의 경우에도 **O(log n)**의 성능을 보장합니다.
