# Array List (동적 배열 리스트)

## 개념
**Array List**는 크기가 고정된 배열(Array)의 단점을 보완하여, 데이터가 추가됨에 따라 **자동으로 크기가 조절되는(Dynamic Resizing)** 자료구조입니다.
인덱스를 통해 데이터에 매우 빠르게 접근할 수 있지만, 중간에 데이터를 삽입하거나 삭제할 때는 데이터 이동이 필요하여 느릴 수 있습니다.

## 구조 (Dynamic Array)
내부적으로 `Object[]` 배열을 사용하여 데이터를 저장합니다.

### 자동 크기 조절 (Resizing)
1.  배열이 가득 찬 상태에서 `add()`가 호출되면,
2.  기존 용량(Capacity)의 **2배 크기**인 새로운 배열을 생성합니다.
3.  기존 배열의 모든 데이터를 새 배열로 복사(Copy)합니다.
4.  참조를 새 배열로 변경하고 데이터를 추가합니다.

```java
// Resizing 로직 예시
if (size == elements.length) {
    int newCapacity = elements.length * 2;
    elements = Arrays.copyOf(elements, newCapacity);
}
```

## 주요 연산 및 시간 복잡도

| 연산 | 설명 | 시간 복잡도 |
| :--- | :--- | :--- |
| **Get (조회)** | 인덱스를 통해 배열 요소에 직접 접근합니다. | **O(1)** |
| **Add (추가 - 끝)** | 배열의 끝에 데이터를 추가합니다. (Resizing 없을 시) | **O(1)** |
| **Add (추가 - 중간)** | 데이터를 삽입하고, 뒤쪽 데이터를 한 칸씩 뒤로 밉니다. | **O(n)** |
| **Remove (삭제)** | 데이터를 삭제하고, 뒤쪽 데이터를 한 칸씩 앞으로 당깁니다. | **O(n)** |
| **Set (수정)** | 인덱스를 통해 특정 위치의 데이터를 수정합니다. | **O(1)** |

> [!NOTE]
> **Array vs LinkedList**
> - **ArrayList**: **검색(Lookup)**이 빈번할 때 유리합니다. (인덱스 접근 O(1))
> - **LinkedList**: **삽입/삭제(Insert/Delete)**가 빈번할 때 유리합니다. (참조 변경 O(1), 단 탐색 비용 제외)

---
> [!TIP]
> **용량 (Capacity) vs 크기 (Size)**
> - **Capacity**: 배열이 담을 수 있는 **총 공간** (메모리 할당량)
> - **Size**: 현재 실제로 저장된 **데이터 개수**
