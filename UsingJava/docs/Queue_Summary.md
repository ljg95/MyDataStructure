# Queue (큐)

## 개념
**Queue**는 "줄을 서다"는 의미로, 먼저 들어온 데이터가 먼저 나가는 **선입선출 (FIFO: First In First Out)** 구조를 가집니다.
마트 계산대 줄이나 프린터 인쇄 대기열과 같습니다.

### 주요 연산
1.  **Offer (Enqueue)**: 큐의 뒤(Rear)에 데이터를 추가합니다.
2.  **Poll (Dequeue)**: 큐의 앞(Front)에 있는 데이터를 꺼냅니다 (제거 + 반환).
3.  **Peek**: 큐의 앞(Front)에 있는 데이터를 확인합니다 (제거하지 않음).

### 구조 (Linked List 기반 구현)
이번 `MyQueue` 구현은 **Linked List**를 기반으로 하여, **데이터 추가와 삭제가 모두 O(1)**의 시간 복잡도를 가지도록 설계했습니다.

#### 핵심 포인트
-   **Front (Head)**: 데이터를 꺼낼 위치 (삭제 포인트).
-   **Rear (Tail)**: 데이터를 추가할 위치 (삽입 포인트).

```java
private Node<T> front; // 삭제 (Poll) 위치
private Node<T> rear;  // 삽입 (Offer) 위치
```

1.  **Offer**: `rear.next`에 새 노드를 연결하고, `rear`를 새 노드로 변경합니다. (O(1))
2.  **Poll**: `front`의 데이터를 반환하고, `front`를 `front.next`로 변경합니다. (O(1))

### 장점 vs 단점
| 특징 | Array 기반 (Circular Queue) | Linked List 기반 (MyQueue) |
| :--- | :--- | :--- |
| **크기** | 고정적 (꽉 차면 늘려야 함) | **동적 (메모리 허용 범위 내 무제한)** |
| **속도** | 인덱스 연산으로 빠름 | 노드 생성/삭제 오버헤드가 있을 수 있으나 O(1) |
| **메모리** | 미리 할당된 공간 낭비 가능 | 포인터 저장을 위한 추가 메모리 필요 |

---
> [!TIP]
> **활용 예시**:
> -   **BFS (너비 우선 탐색)** 알고리즘
> -   프로세스 스케줄링 (운영체제)
> -   프린터 인쇄 대기열
> -   데이터 버퍼 (Buffer)
